3 самые вещи :
выражение функции объекты
Объект-набор свойств,а свойство = имя:значение
console.log-выражение,то что возвращает результат 
console-объект 
log-функция
Правильное название переменных для ТИПОВ И КЛАССОВ=> PascalCase Example:FirstProgramm
Для КОНСТАНТ DB_PASSWORD=> AN_123123-не изменяется
В остальных случаях camelCase
----------Объявление переменных(let и const)
let-создание переменных с возможностью последующего изменения(ПЕРЕПРЕСВОЕНИЯ)
let a = 10 
a= 25
const-создание переменных БЕЗ возможности перепресвоения
const a = 10
a=20-//TypeError:
------------Типы данных
Существует 2 типа данных ПРИМИТИВНЫЕ и ССЫЛОЧНЫЕ
Примитивные:string,boolean,number,null,undefined,symbol
Сохраняются в памяти напрямую
Разница между NULL и UNDEFINED в том что 
NULL-задаете именно вы и говорит о том,что сейчас значения НЕТ,но возможно позже /n
оно может быть задано
UNDEFINED-возвращает вам браузер,без возможности присваивания
Ссылочные:object
Имеет ссылку на конкретный объект
Пример работы ссылок:

const objectA={
    a:10,
    b:'ggwp'
} 

const objectOfA = objectA;

objectOfA.a=20;

//objectA.a -> 20 

-------------------Динамическая типизация
string a = 'abc'-статическая типизация
a = 'abc' - динамическая типизация //string
Важно!!

string a = 'abc'
a=10 ->ERROR

a='abc'
a=10  ->OK

JAVASCRIPT НЕ ЖЕСТКО ТИПИЗИРОВАННЫЙ ЯЗЫК!!!!
Из-за этого могу выходить ошибки 

function a(){
    console.log('jopa')
}
a= 123
a()
//TypeError: a is not a function

-----ФИКС!
CONTS

const a = () =>{
	contsole.log('privet')
}
a=10 //ERROR

Правила работы с переменными 
1.Все переменные объявлять перед их использованием 
2.Стараться использовать conts везде,где это возможно
---------Работа конкретно с объектами 

const myHome={
    house:123,
    street:'Pushino'
}
myHome.house=12
console.log(myHome)
>{ house: 12, street: 'Pushino' }

Не смотря на то что объект myHome имеет тип const
Изменение свойств происходит нормально,так как мы меняем свойства какого то объекта /n
в памяти,а не саму ссылку(myHome)
------------Удаление свойств
delete myHome.house

-----------Другой синтаксис работы с объектами
Подразумевает конкретную работу со ЗНАЧЕНИЯМИ свойств объекта
Пример:используем значение переменной для присвоение имени свойству

const age = 'возраст' //используется для передачи имени свойству
myHome[age] = 'мне 10' //используется для передачи имени значения КОНКРЕТНОМУ свойству  
console.log(myHome)

---------Вложенные свойства

const myHome={
    house:{
        floar:2,
        numb:10
    },
    street:'Pushino'
}
console.log(myHome.house.numb)

-------Сокращенный формат записи свойств 

const home={
    home,   //home:home
    dropMy, //dropMy:dropMy
    streetHome : true
}

----Глобальные объекты
Window-веб браузеры
Global-node.js
globalThis - универсальный метод для обоих


----Метод
Метод-это свойство объекта,значение которого функция

const home={
    floar:2,
    streetName: function(){     //функция 
        console.log('Pushkino') 
    }
}
home.streetName();

const home={
    floar:2,
    streetName(){ 		//краткая запись функции 
        console.log('Pushkino')
    }
}
home.streetName();

--------Метод vs Свойства объектов
Метод содержат функции 
Свойства НЕ содержат функции
Тогда:
myCity.city=>доступ к значению свойства
myCity.city()=>вызов метода
----JSON
JSON-JAVASCRIPT OBJECT NOTATION
Используется для обмена данными между ПК
Имеет вид: {"userId":1,"id":1,"title":Test} => JSON
{userId:1,id:1,title:"Test"} => JS
Для конвертация JSON в объект(JS)
JSON.parse()
Для конвертация объект(JS) в JSON
JSON.stringify()
Примеры:

JSON.stringify(post)
'{"title":"My post","likesQty":5}' //ВАЖНО это СТРОКА ''

JSON.parse(strtingify)
{title: 'My post', likesQty: 5}

--------------Мутация 
Пример:

const person={
    name:'Bob',
    age:123
}
const person2=person
person2.age=19
person2.name='Alex' 
console.log(person) //{ name: 'Alex', age: 19 }

Суть в том,что в отличие от переменных(ПРИМИТИВНЫХ) ссылочный тип работает именно с 1 конкретным объектов в памяти /n
через множество ссылок,поэтому при изменении 1 из них меняются и ОСТАЛЬНЫЕ
Избежание таких ситуаций:
1Вариант(Object.assign({},person))-создает новую ссылку на новый объект,другими словами создает КОПИЮ первого

const person={
    name:'Bob',
    age:123
}
const person2= Object.assign({},person) 
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 	

Важно!!!!! Работает только с КОРНЕВЫМИ ОБЪЕКТАМИ без вложенностей.
2Вариант{...}-оператор разделения на свойства

const person={
    name:'Bob',
    age:123
}
const person2= {...person}
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 

Важно!!!!! Работает только с КОРНЕВЫМИ ОБЪЕКТАМИ без вложенностей.

3Вариант(JSON)-парсировка с помощью JSON-----ЛУЧШИЙ вариант

const person={
    name:'Bob',
    age:123
}
const person2= JSON.parse(JSON.stringify(person))
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 

Позволяет ПОЛНОСТЬЮ копировать объект.

-----------Функции
Функция-это блок кода,который можно выполнять МНОГОКРАТНО
Функция может быть 
1.Именованной
2.Присвоена переменной 
3.Анонимной
4.Аргументом при вызове другой функции
5.Значением свойства объекта=МЕТОДОМ
function(a,b)=> a,b-параметры
Функция ВСЕГДА возвращает значение,и если у нас нет return то она возвращает UNDEFINED