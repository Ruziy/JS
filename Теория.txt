3 самые главные вещи :
выражение функции объекты
Объект-набор свойств,а свойство = имя:значение
console.log-выражение,то что возвращает результат 
console-объект 
log-функция
Правильное название переменных для ТИПОВ И КЛАССОВ=> PascalCase Example:FirstProgramm
Для КОНСТАНТ DB_PASSWORD=> AN_123123-не изменяется
В остальных случаях camelCase
----------Объявление переменных(let и const)
let-создание переменных с возможностью последующего изменения(ПЕРЕПРЕСВОЕНИЯ)
let a = 10 
a= 25
const-создание переменных БЕЗ возможности перепресвоения
const a = 10
a=20-//TypeError:
------------Типы данных
Существует 2 типа данных ПРИМИТИВНЫЕ и ССЫЛОЧНЫЕ
Примитивные:string,boolean,number,null,undefined,symbol
Сохраняются в памяти напрямую
Разница между NULL и UNDEFINED в том что 
NULL-задаете именно вы и говорит о том,что сейчас значения НЕТ,но возможно позже /n
оно может быть задано
UNDEFINED-возвращает вам браузер,без возможности присваивания
Ссылочные:object
Имеет ссылку на конкретный объект
Пример работы ссылок:

const objectA={
    a:10,
    b:'ggwp'
} 

const objectOfA = objectA;

objectOfA.a=20;

//objectA.a -> 20 

-------------------Динамическая типизация
string a = 'abc'-статическая типизация
a = 'abc' - динамическая типизация //string
Важно!!

string a = 'abc'
a=10 ->ERROR

a='abc'
a=10  ->OK

JAVASCRIPT НЕ ЖЕСТКО ТИПИЗИРОВАННЫЙ ЯЗЫК!!!!
Из-за этого могу выходить ошибки 

function a(){
    console.log('jopa')
}
a= 123
a()
//TypeError: a is not a function

-----ФИКС!
CONTS

const a = () =>{
	contsole.log('privet')
}
a=10 //ERROR

Правила работы с переменными 
1.Все переменные объявлять перед их использованием 
2.Стараться использовать conts везде,где это возможно
---------Работа конкретно с объектами 

const myHome={
    house:123,
    street:'Pushino'
}
myHome.house=12
console.log(myHome)
>{ house: 12, street: 'Pushino' }

Не смотря на то что объект myHome имеет тип const
Изменение свойств происходит нормально,так как мы меняем свойства какого то объекта /n
в памяти,а не саму ссылку(myHome)
------------Удаление свойств
delete myHome.house

-----------Другой синтаксис работы с объектами
Подразумевает конкретную работу со ЗНАЧЕНИЯМИ свойств объекта
Пример:используем значение переменной для присвоение имени свойству

const age = 'возраст' //используется для передачи имени свойству
myHome[age] = 'мне 10' //используется для передачи имени значения КОНКРЕТНОМУ свойству  
console.log(myHome)

---------Вложенные свойства

const myHome={
    house:{
        floar:2,
        numb:10
    },
    street:'Pushino'
}
console.log(myHome.house.numb)

-------Сокращенный формат записи свойств 

const home={
    home,   //home:home
    dropMy, //dropMy:dropMy
    streetHome : true
}

----Глобальные объекты
Window-веб браузеры
Global-node.js
globalThis - универсальный метод для обоих


----Метод
Метод-это свойство объекта,значение которого функция

const home={
    floar:2,
    streetName: function(){     //функция 
        console.log('Pushkino') 
    }
}
home.streetName();

const home={
    floar:2,
    streetName(){ 		//краткая запись функции 
        console.log('Pushkino')
    }
}
home.streetName();

--------Метод vs Свойства объектов
Метод содержат функции 
Свойства НЕ содержат функции
Тогда:
myCity.city=>доступ к значению свойства
myCity.city()=>вызов метода
----JSON
JSON-JAVASCRIPT OBJECT NOTATION
Используется для обмена данными между ПК
Имеет вид: {"userId":1,"id":1,"title":Test} => JSON
{userId:1,id:1,title:"Test"} => JS
Для конвертация JSON в объект(JS)
JSON.parse()
Для конвертация объект(JS) в JSON
JSON.stringify()
Примеры:

JSON.stringify(post)
'{"title":"My post","likesQty":5}' //ВАЖНО это СТРОКА ''

JSON.parse(strtingify)
{title: 'My post', likesQty: 5}

--------------Мутация 
Пример:

const person={
    name:'Bob',
    age:123
}
const person2=person
person2.age=19
person2.name='Alex' 
console.log(person) //{ name: 'Alex', age: 19 }

Суть в том,что в отличие от переменных(ПРИМИТИВНЫХ) ссылочный тип работает именно с 1 конкретным объектов в памяти /n
через множество ссылок,поэтому при изменении 1 из них меняются и ОСТАЛЬНЫЕ
Избежание таких ситуаций:
1Вариант(Object.assign({},person))-создает новую ссылку на новый объект,другими словами создает КОПИЮ первого

const person={
    name:'Bob',
    age:123
}
const person2= Object.assign({},person) 
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 	

Важно!!!!! Работает только с КОРНЕВЫМИ ОБЪЕКТАМИ без вложенностей.
2Вариант{...}-оператор разделения на свойства

const person={
    name:'Bob',
    age:123
}
const person2= {...person}
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 

Важно!!!!! Работает только с КОРНЕВЫМИ ОБЪЕКТАМИ без вложенностей.

3Вариант(JSON)-парсировка с помощью JSON-----ЛУЧШИЙ вариант

const person={
    name:'Bob',
    age:123
}
const person2= JSON.parse(JSON.stringify(person))
person2.age=19
person2.name='Alex'
console.log(person) //{ name: 'Bob', age: 123 }
console.log(person2) //{ name: 'Alex', age: 19 } 

Позволяет ПОЛНОСТЬЮ копировать объект.

-----------Функции
Функция-это блок кода,который можно выполнять МНОГОКРАТНО
Функция может быть 
1.Именованной
2.Присвоена переменной 
3.Анонимной
4.Аргументом при вызове другой функции
5.Значением свойства объекта=МЕТОДОМ
function(a,b)=> a,b-параметры
Функция ВСЕГДА возвращает значение,и если у нас нет return то она возвращает UNDEFINED
Внутри функции не рекомендуется мутировать внешние объекты

----------Колбэк функции
Смысл колбэк функции в том,чтобы в теле своей функции вызывать другую функцию

---------Правила работы с функциями
1.Называть функции исходя из выполняемых задач
2.ОДНА функция должна выполнять ОДНУ задачу 
3.Не рекомендуется изменять внешние относительно функции переменные
Другими словами нужно создавать дубликаты переменных прямо в теле функции

======================================Области видимости
Область видимости определяет границы действия переменной 
Существует 2 типа переменных ГЛОБАЛЬНЫЕ и ЛОКАЛЬНЫЕ
Пример 

let a ----global A (undefined)
let b ----global B (undefined)
function myFn(){
    let b -----local B (undefined)
    a=true ----global A (true)
    b=10 ------local B (10)
    console.log("Local b "+b)
}
myFn()
console.log(a) ----global A (true)
console.log("Global b "+b) ------local B (10)

-----Цепочка областей видимости
Пример:

const a = 10 =====создается глобальная переменная а
function myFn(){-------------- 
    function yourFn(){ ....
        console.log(a) .... 1 уровень видимости а здесь не объявлена,идем на уровень выше
    }		       ....
    yourFn() ----------------- 2 уровень переход на уровень выше осуществляется с помощью вызова самой функции /n
}			       здесь переменная а тоже не объявлена идем выше
myFn ============================ 3 уровень видимости(глобальный) здесь а объявлена

-----Типы областей видимости
1.Глобальная 
2.Область видимости функции
3.Область видимости блока - переменные объявление с помощью let и const имеют ограниченную область в блоке которого /n
они созданы(if,for,и тд )

-----Необъявленные переменные 
В случае если переменная строко не объявлена:

function ggwp(){
    a=true; -необъявленная переменная
}
ggwp()
console.log(a); //true

Происходит это из за того,что js поддерживает динамическое присвоение и эта переменная будет создана в ГЛОБАЛЬНОЙ ОБЛАСТИ ВИДИМОСТИ
Чтобы такого не происходило нужно использовать:
'use strict' и он будет выдавать ошибку не присвоенным переменным

------Правила работы с переменными
1.Все переменные объявлять перед их использованием
2.Стараться использовать const везде где это возможно
3.Внутри функций не изменять переменные с внешних областей видимости

====================Операторы
Оператор- это встроенная функция
1.Арифметические
2.Сравнение
3.Логические (&&-и,||-или)
4.Присваивания
----Операнды(аргументы) - все что находится слева и справа оператора
a=10
a - слева
10 - справа
----Унарные операторы
У унарных операторов всегда только один операнд или аргумент
a++,+a, delete obj.a,new Object() ....
----Бинарные операторы 
Имеют 2 аргумента
a = 5, a+b, a+=5, a === b ,a && b ...

-------Записи
-Инфиксная запись (оператор между операндами)
a = true 
a + b 
a > b
-Префиксная запись (оператор перед операндами)
++b
delete obj.a
-Постфиксная запись (оператор после операндами)
a++
myFunction()

------Логические операторы 
1. !-(не) имеет логический тип,возвращает либо true/false
2. ||(или) и &&(и) - возвращает значение 1 из операндов 
------!! - двойное отрицание 
Пример: 
!! 10 //true
!! "abc" // true
Используются для привидения к логическому типу:
Пустой объект возвращает TRUE

-------Операторы короткого замыкания (&&,||) - ищет первое короткое замыкание
Выражение 1 && Выражение 2 - в 1 случае,если 1-ое выражение ЛОЖНОЕ(false),то возвращается Выражение 1
И второе выражение даже не рассматривается.
В 2 случае, если 1-ое выраж. ПРАВДИВОЕ(true), то рассматриваем Выражение 2 и возвращаем его в любом 
случае и false и true
Выражение 1 || Выражение 2 - В 1 случае, если 1-ое выражение ИСТИННОЕ(true),то возвращается Выражение 1
И второе выражение даже не рассматривается.

-----Оператор ...
Раздляет объект на свойства.

const button ={
    width:200,
    text:"Buy"
}
const redButton = {
    ...button,
    color:'red'
}
console.table(redButton)
////////////////////////
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│  width  │  200   │
│  text   │ 'Buy'  │
│  color  │ 'red'  │
└─────────┴────────┘

--------Конкатенация строк ("hello" + "wrld")

--------Шаблонные строки
Пример такого кода:

const hello = 'hello'
const wrld = 'wrld'
console.log(`${hello} ${wrld}`)

Позволяет соединять строки без использования конкатенации


-------Объявленная функция VS Функциональное выражение
Функциональное выражение всегда остаются АНОНИМНЫМИ и не может использоваться АВТОНОМНО
Функциональное выражение нельзя просто так написать в коде,можно присваивать ее переменной
Но ее можно вызывать как аргумент в другой функции то есть КОЛБЕК функция
Пример:

setTimeout(function(){
console.log('Отложенное сообщение'},1000)

-----Стрелочные функции
Синтаксис:

(a,b) =>{
      let c 
      a = a +1
      c = a + b
      return c	
}

Стрелочная функция = выражение и всегда анонимна
Даётся имя с помощью переменной const myFunction = ...
Используется для того, чтобы не переименовывать уже существующие выражения
setTimeout(() => {
console.log('Отложенное сообщение'},1000)
Сокращенный синтаксис:
(a,b) => a+b 
Можно опускать фигурные скобки,если функция состоит из ОДНОГО выражения, и используется неявный возврат значения

--------Дефолтное значение параметра 
function myFunction (value, multiplier = 1)
В случае если будет только 1 аргумент то 2 примет 1
Возврат Объекта через функцию без МУТАЦИИ
Код:

const newPost = (post,addedAt = Date()) =>({ -----с помощью этих круглых скобок реализуется создание нового объекта	
    ...post,
    addedAt
})					     -----с помощью этих круглых скобок реализуется создание нового объекта	
const firstPost = {
    id:1,
    author:'Alex'
}

console.log(newPost(firstPost))


----------Отловля ошибок в JS
Генерация собственной ошибки:

const myFuncWithError = () =>{
    throw new Error('Come error..')
} 

Способ отловли ошибок реализуется через try,catch:
Синтаксис:

const myFuncWithError = () =>{
    throw new Error('Come error..')
} 				--------Создание ошибки
try{
    myFuncWithError() ------попытка вызова функции с ошибкой
}catch(error){	      ------в случае если появится ошибка выполняется код дальше	
    console.error(error) -----выводит полную структуру ошибку но без остановки кода
    console.log(error.message) ----выводит сопроводительный текст ///'Come error..'
}
console.log('Continue...') 

=============Инструкция
1.Выражение 
2.Инструкция 
3.Выражение-инструкция
Напоминание! Выражение всегда возвращает значение
!!!Инструкция выполняется действия
Инструкция обычно заканчивается точкой с запятой и отделяется строками
Инструкции нельзя вызывать как аргументы в вызовах функции
Синтаксис:

let a = 10;
const b = ()=>{};
if(){
  console.log();
}

Разница между выражением и инструкцией в том что !!Инструкции нельзя вызывать как аргументы в вызовах функции
Пример:

function myFn(a){
	console.log(a);
}
let c = 10   ///выражение
myFn(c=10+1) ///выражение
myFn(c=10+1;)///инструкция => Error
myFn(let b)  ///инструкция => Error

==============Массив
Массив - это объект с цифровыми именами свойств
Синтаксис объявления:

const myArray = [1,2,3]
console.log(myArray)

const myArrayTwo = new Array(1,2,3)
console.log(myArrayTwo)

-----Массив vs Объект 
Почему myArray = [1,2,3] и myObject={0:1,1:2,2:3,length:3} не равны
Все дело в прототипе _proto_ можно найти в инструментах разработчика(F12)
Именно прототип меняет структуру объекта,у массива это Array(0),у объекта это Object
Так как значение имеет числовой тип, то точечная запись не будет работать 
myArray.0 ///Error
myArray[1] /// 2

----Методы массива
Функции высшего порядка,функции прототипов
1.push - добавляет элемент в конец массива
array.push(4) ///[.,.,4]
2.pop - удаляет последний элемент в массиве 
array.pop()
Можно присвоить удаленное значение определенной переменной
const lastEl = array.pop()
3.unshift - добавляет элемент в начало массива
array.unshift(true)
4.shift - удаляет первый элемент массива,работает также как и pop
----Foreach
Используется для работы с каждым элементом массива(перебор)
Синтаксис:

const array = [1,2,3]
array.forEach((el)=> console.log(el*2))
///2,4,6

Важно!! Сам массив не мутирует, то есть значения остаются такими же [1,2,3]
Также сам по себе метод ничего не возвращает
-----Map
Используется для возврата НОВОГО массива с новыми элементами на основе другого массива
Работает похожим способом как и foreach
Синтаксис:

const array = [1,2,3]
const myArray = array.map(el => el*2)
console.log(myArray)

Исходный массив остаётся прежним
==================Деструктуризация
Применяется для объявления новых переменных и присваивание значений на основе значений свойств объекта
Синтаксис:

const userProfile = {
    name:'Bogdan',
    age:12,
    hasSigned:false
}
const {name,age,hasSigned} = userProfile ///Важно =Имя объекта
console.log(name,age,hasSigned)

--------------Деструктуризация в массивах
Пример:
const fruits = ['banana','apple']
const [firstFruit,secondFtruit] = fruits
console.log(firstFruit,secondFtruit)

------------Деструктуризация в функциях
Пример:
const userProfile = {
    name:"Alex",
    commentQty:23
}

const myFn = ({name,commentQty})=> { ///js автоматически адаптирует конкретный объект,который будет
    if(!commentQty){                 ///аргументом
        return `Hello i am ${name} and i havent any comments`
    }
    else{
        return `Hello i am ${name} and i have ${commentQty} comments`
    }
}
myFn(userProfile)
----------Условные инструкции
1.if
2.if..else
3.switch
4.тернарный оператор => выражение
Двойное условие: if (age>=12 && age<18)				
------Switch
Синтаксис:

const month = 2 
switch(month){
    case 12:{
        console.log("Декабрь")
        break
    }
    case 1:{
        console.log("Январь")
        break
    }
    case 2:{
        console.log("Февраль")
        break
    }
    default:{
        console.log("Не зимний месяц")
    }
}

-----Тернарный оператор
У тернарного оператора 3 операнда и он является выражением=>всегда возвращает значение
Синтаксис:
Условие1 ? Выражение1 : Выражение2
В случае если условие1 верно=> Выражение1
В случае если условие1 лож=> Выражение2
Другой синтаксис:
Условие
?Выражение1
:Выражение2
Пример 1:
value && value1 
?Function_1()
:Function_2()


==============Циклы
Классический синтаксис массива:
1.for(let i = 0;i<5;i++){

}

Перебор массива:
2.const myArray = [1,2,3,4,5,"banana"]
myArray.map((el,index)=>{
    console.log(el,index)
})

3.while цикл:
while(условие пока true){

}
Важно!! Цикл может выполняться бесконечное количество раз в случае соблюдения условия 

4.do while цикл:
do{
 действие пока условие true
}
while(условие)
Важно!! Цикл выполнится 1 РАЗ в случае если условие будет FALSE

5.for in цикл для перебора свойств объекта:
const myObject = {
    z:10,
    x:"Sasha",
    c:"Razuv"
}
for(const keys in myObject){
    console.log(keys,myObject[keys])
}

6.Foreach для объектов 
а)Для свойств объекта:
const myObject = {
    z:1,
    x:"Sasha",
    c:"Razuv"
}
Object.keys(myObject).forEach((el)=>{
    console.log(el)
})
б)Для значений объекта:
const myObject = {
    z:1,
    x:"Sasha",
    c:"Razuv"
}
Object.values(myObject).forEach((el)=>{
    console.log(el)
})
7.for of для перебора символо в строке и элементов массива:
const myString = "Sasha" 
for ( const cymbol of myString){
    console.log(cymbol)
}
Важно!! Не работает с ОБЪЕКТАМИ

=======Модули
Модули позволяют структурировать код
Используются для предотвращения дублирования кода 
export используется для переноса блока кода из одного файла 
import используется для принятия блока кода 
Пример синтаксиса:
For export:
...any code
export default name
For import:
import (любое имя если при экспорте используется default) from 'way'
ВАЖНО!!!!! Формат файла должен иметь вид не JS а MJS
1)Для экспорта нескольких элементов используется следующий синтаксис:
const one,two
export {one,two}-важно что для переменных используется КОНКРЕТНОЕ имя
2)Для импорта используется следующий синтаксис:
import {one as FIRST - есть возможность использовать АЛИАСЫ
two} from 'way'
Правила работы с модулями:
1.Модули должны быть одноцелевыми
2.Располагайте все export инструкции внизу файла
3.Располагайте все import инструкции сверху файла 
4.По возможности использутей export default

=======Классы и прототипы
Классы позволяют создавать прототипы для объектов
На основании прототипов создаются экзмепляры
Экземпляры имеют могут иметь собственные свойства и методы
Экземпляры наследуют свойства и методы прототипов
This переменная указывает на КОНКРЕТНЫЙ экземпляр класса
Синтаксис:
class Comment {
    constructor(text){    ---У каждого класса есть свой конструктор,то есть структура при его вызове 
        this.text = text
        this.votesQty = 0
    }
    upvote(){
        this.votesQty += 1
    }
}
Пример вызова класса сверху:
const tryClass = new Comment("Hello")
console.log(tryClass)   
//Comment { text: 'hai', votesQty: 0 }
Создаётся объект исходя из структуры класса
-------Цепочка прототипов(наследование)
В нашем случае:
tryClass => Comment => Object
tryClass наследует всю структуру и методы из Comment, а последний соотвественно из Object
Для проверки наследования используют instanceof
------Статические методы(static)
Метод доступен как свойство класса и НЕ НАСЛЕДУЕТСЯ экземплярами класса
пример синтаксиса:
class TestClass{
   static staticMetod(){
	console.log("Hello wrld")   
}
}
Обращение:
TestClass.staticMetod()
Разница на Теории:
Чтобы увидеть статический метод необходимо зайти в dir определенного класса
В случае создания прототипов(экземпляров) этот метод увидеть не получится
Он находится в конструктуре класса
=================Расширение других классов
Используется для наследования уже созданных классов и дополнения их своими методами и структурами
Пример синтаксиса:
class NumbersArray extends Array{
    sum(){
        return this.reduce((el,acc)=> acc+=el,0)
    }
}
const test = new NumbersArray(1,2,3)
console.log(test.sum())
Идёт наследование класса Array и создание своего метода с использованием метода array(reduce)